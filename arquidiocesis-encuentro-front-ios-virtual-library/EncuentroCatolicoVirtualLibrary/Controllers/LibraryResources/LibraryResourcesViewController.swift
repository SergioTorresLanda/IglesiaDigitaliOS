//
//  LibraryResourcesViewController.swift
//  EncuentroCatolicoVirtualLibrary
//
//  Created Desarrollo on 15/04/21.
//  Copyright © 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import AVKit
import WebKit

class LibraryResourcesViewController: UIViewController, LibraryResourcesViewProtocol {
    
    @IBOutlet weak var documentCollection       : UICollectionView!
    @IBOutlet weak var videosCollection         : UICollectionView!
    @IBOutlet weak var documentCollectionHeight   : NSLayoutConstraint! 
    @IBOutlet weak var videosCollectionHeight   : NSLayoutConstraint! 
    @IBOutlet weak var btnShowMore              : UIButton!
    @IBOutlet weak var lblDocument              : UILabel!
    @IBOutlet weak var videosTitleStack         : UIStackView!
    
    var presenter: LibraryResourcesPresenterProtocol?
    var expandSection: Bool = false
    var videoResources: [Resource] = []
    var pdfImageResources: [Resource] = []
    
    override func viewDidLoad() {
        super.viewDidLoad()
        NotificationCenter.default.addObserver(self, selector: #selector(loadResources(notification:)), name: Notification.Name(rawValue: "loadResources"), object: nil)
        documentCollection.delegate = self
        documentCollection.dataSource = self
        videosCollection.delegate = self
        videosCollection.dataSource = self
        documentCollection.register(UINib(nibName: "DocumentCVCell", bundle: Bundle.local), forCellWithReuseIdentifier: "doc")
        documentCollection.register(UINib(nibName: "MiniVideoCVCell", bundle: Bundle.local), forCellWithReuseIdentifier: "miniVid")
        documentCollection.register(UINib(nibName: "ExtendedVideoCVCell", bundle: Bundle.local), forCellWithReuseIdentifier: "vid")
    }
    
    
    @objc func loadResources(notification: NSNotification){
        let resources = notification.object as? [Resource] ?? []
        videoResources = resources.filter{ $0.type == "VIDEO"}
        for item in resources{
            if item.type == "IMAGE" || item.type ==  "PDF" || item.type == "LINK"{
                pdfImageResources.append(item)
            }
        }
    }
    
    @IBAction func viewAll(_ sender: Any){
        let layout = self.videosCollection.collectionViewLayout as! UICollectionViewFlowLayout
        if expandSection == false{
            expandSection = true
            btnShowMore.setTitle("Ver menos", for: .normal)
            videosCollectionHeight.constant = 480
            layout.scrollDirection = UICollectionView.ScrollDirection.vertical
        }else{
            btnShowMore.setTitle("Ver todo", for: .normal)
            videosCollectionHeight.constant = 190
            layout.scrollDirection = UICollectionView.ScrollDirection.horizontal
            expandSection = false
        }
        videosCollection.reloadData()
    }
}

extension LibraryResourcesViewController: UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout{
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        if collectionView == documentCollection{
            if pdfImageResources.count == 0{
                lblDocument.isHidden = true
                documentCollection.isHidden = true
            }else{
                lblDocument.isHidden = false
                documentCollection.isHidden = false
            }
            return pdfImageResources.count
        }else{
            if videoResources.count == 0{
                documentCollectionHeight.constant = 450.0
                videosTitleStack.isHidden = true
                videosCollection.isHidden = true
            }else{
                documentCollectionHeight.constant = 300.0
                videosTitleStack.isHidden = false
                videosCollection.isHidden = false
            }
            return videoResources.count
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        if collectionView == documentCollection{
            let cell = documentCollection.dequeueReusableCell(withReuseIdentifier: "doc", for: indexPath) as! DocumentCVCell
            let libraryData = pdfImageResources[indexPath.row]
            cell.lblDescription.text = libraryData.resourceDescription
            cell.lblTitle.text = libraryData.title
            cell.tag = libraryData.id ?? -1
            cell.accessibilityHint = libraryData.url
            DispatchQueue.main.async {
                if libraryData.type == "LINK"{
                    cell.imgView.image = UIImage(named: "noData", in: Bundle.local, compatibleWith: nil)
                }else{
                    let url = URL(string: libraryData.url ?? "www.com")
                    let data = try? Data(contentsOf: url!)
                    if data != nil {
                        cell.imgView.image = UIImage(data: data!)
                    }else{
                        cell.imgView.image = UIImage(named: "noData", in: Bundle.local, compatibleWith: nil)
                    }
                }
            }
            return cell
        }else{
            let libraryData = videoResources[indexPath.row]
            switch expandSection{
            case true:
                let cell = documentCollection.dequeueReusableCell(withReuseIdentifier: "vid", for: indexPath) as! ExtendedVideoCVCell
                cell.lblTitle.text = libraryData.title
                cell.lblSubtitle.text = libraryData.resourceDescription
                let webConfiguration = WKWebViewConfiguration()
                webConfiguration.allowsInlineMediaPlayback = true
                webConfiguration.mediaTypesRequiringUserActionForPlayback = []
                var videoPlayer: WKWebView!
                videoPlayer = WKWebView(frame: CGRect(x: 0, y: 0, width:  cell.imgView.frame.size.width, height: cell.imgView.frame.size.height), configuration: webConfiguration)
                videoPlayer.navigationDelegate = self
                cell.imgView.addSubview(videoPlayer)
                
                
                if let videoURL:URL = URL(string: libraryData.url?.embedYoutubeURL() ?? "") {
                    let request:URLRequest = URLRequest(url: videoURL)
                    videoPlayer.load(request)
                }
                
                return cell
            case false:
                let cell = documentCollection.dequeueReusableCell(withReuseIdentifier: "miniVid", for: indexPath) as! MiniVideoCVCell
                cell.lblTitle.text = libraryData.title
                let webConfiguration = WKWebViewConfiguration()
                webConfiguration.allowsInlineMediaPlayback = true
                webConfiguration.mediaTypesRequiringUserActionForPlayback = []
                var videoPlayer: WKWebView!
                videoPlayer = WKWebView(frame: CGRect(x: 0, y: 0, width:  cell.imgView.frame.size.width, height: cell.imgView.frame.size.height), configuration: webConfiguration)
                videoPlayer.navigationDelegate = self
                cell.imgView.addSubview(videoPlayer)
                
                if let videoURL:URL = URL(string: libraryData.url?.embedYoutubeURL() ?? "") {
                    let request:URLRequest = URLRequest(url: videoURL)
                    videoPlayer.load(request)
                }
                return cell
            }
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        if collectionView == documentCollection{
            let libraryData = pdfImageResources[indexPath.row]
            let view = BrowserViewController(nibName: "BrowserViewController", bundle: Bundle.local)
            view.screenURL = libraryData.url
            self.navigationController?.pushViewController(view, animated: true)
        }
        if collectionView == videosCollection{
            let libraryData = videoResources[indexPath.row]
            guard let url = URL(string: libraryData.url?.embedAndPlayYoutubeURL() ?? "www.com") else { return }
            let view = BrowserViewController(nibName: "BrowserViewController", bundle: Bundle.local)
            view.screenURL = url.absoluteString
            self.navigationController?.pushViewController(view, animated: true)
        }
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        if collectionView == documentCollection{
            let width = documentCollection.bounds.width
            return CGSize(width: width, height: 122.0)
        }else{
            switch expandSection {
            case true:
                return CGSize(width: videosCollection.bounds.width, height: 74.0)
            case false:
                return CGSize(width: 192.0, height: 226.0)
            }
        }
    }
}


extension LibraryResourcesViewController: WKNavigationDelegate{
    
    func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
        var activityIndicator: UIActivityIndicatorView!
        activityIndicator = UIActivityIndicatorView()
        activityIndicator.center = webView.center
        activityIndicator.hidesWhenStopped = true
        activityIndicator.style = .gray
        activityIndicator.isHidden = false
        activityIndicator.startAnimating()
        webView.addSubview(activityIndicator)
    }
    
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        for view in webView.subviews {
            if view is UIActivityIndicatorView{
                view.removeFromSuperview()
            }
        }
    }
}


extension String{
    func embedYoutubeURL() -> String{
        if self.contains("youtube"){
            return self.replacingOccurrences(of: "watch?v=", with: "embed/")
        }else{
            return self
        }
    }
    
    func embedAndPlayYoutubeURL() -> String{
        if self.contains("youtube"){
            return self.replacingOccurrences(of: "watch?v=", with: "embed/") + "?autoplay=1"
        }else{
            return self
        }
    }
}
